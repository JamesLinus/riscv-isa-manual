\chapter{Hypervisor Extension, Version 0.0}
\label{hypervisor}

This chapter describes the RISC-V hypervisor extension, which virtualizes the
supervisor-level architecture to efficiently host guest operating systems atop
a type-1 or type-2 hypervisor.  The hypervisor extension adds a second level
of address translation, from supervisor-physical addresses to
hypervisor-physical addresses, to virtualize the memory and memory-mapped I/O
subsystems.  The hypervisor extension also adds a new privilege mode, {\em
hypervisor mode} (H-mode), where the hypervisor runs.  H-mode acts the same as
S-mode, but with additional instructions and CSRs that control second-level
address translation and support hosting an S-mode guest.  Existing S-mode
operating systems can execute without modification either in H-mode or as
S-mode guests.

An H-mode OS or hypervisor interacts with the machine through the same SBI
as would an S-mode OS.  An H-mode hypervisor is expected to implement the
SBI for its S-mode guest.

\begin{commentary}
The privileged architecture is designed to simplify the use of classic
virtualization techniques, where a guest OS is run at user-level, as
the few privileged instructions can be easily detected and trapped.
The hypervisor extension improves virtualization performance by
reducing the frequency of these traps.
\end{commentary}

The hypervisor extensions are enabled by setting bit 7 in the {\tt misa} CSR,
which corresponds to the letter H.  When {\tt misa}[7] is clear, the hart
behaves as though this extension were not implemented, and attempts to use
hypervisor CSRs or instructions raise an illegal instruction exception.

\section{Privilege Modes}

The current {\em virtualization mode}, denoted V, indicates whether the hart
is currently executing in a guest.  When V=1, the hart is either in S-mode, or
in U-mode under an S-mode OS.  When V=0, the hart is either in M-mode, in
H-mode, or in U-mode under an H-mode OS.  The virtualization mode also
indicates whether two-level address translation is active (V=1) or inactive
(V=0).  Table~\ref{h-operating-modes} lists the possible operating modes of
a RISC-V hart with the hypervisor extension.

\begin{table*}[h!]
\begin{center}
\begin{tabular}{|c|c||l|l|l|}
  \hline
   Privilege & Virtualization & \multirow{2}{*}{Abbreviation} & \multirow{2}{*}{Name} & Two-Level \\
   Mode      & Mode (V)       &                               &                       & Translation \\ \hline
   U         & 0              & U-mode  & User mode & Off \\
   S         & 0              & H-mode  & Hypervisor mode & Off \\
   M         & 0              & M-mode  & Machine mode & Off \\
   U         & 1              & U-mode  & User mode & On \\
   S         & 1              & S-mode  & Supervisor mode & On \\
  \hline
 \end{tabular}
\end{center}
\caption{Operating modes with the hypervisor extension.}
\label{h-operating-modes}
\end{table*}

\section{Hypervisor CSRs}

An H-mode hypervisor uses the S-mode CSRs to interact with the exception,
interrupt, and address-translation subsystems.
Additional CSRs are provided to H-mode, but not to S-mode, to control
the behavior of an S-mode guest:
{\tt hvtval}, {\tt hstatus}, {\tt hedeleg}, and
{\tt hideleg}.

Additionally, several {\em background} supervisor CSRs are copies of one of
the existing {\em foreground} supervisor CSRs.  For example, the {\tt
bsstatus} CSR is the background copy of the foreground {\tt sstatus} CSR.
When transitioning between virtualization modes (V=0 to V=1, or vice-versa),
the implementation swaps the background supervisor CSRs with their foreground
counterparts.  When V=0, the background supervisor CSRs contain the S-mode
guest's version of those CSRs, and the foreground supervisor CSRs contain
H-mode's version.  When V=1, the background supervisor CSRs contain H-mode's
version, and the foreground supervisor CSRs contain the S-mode guest's
version.  The background registers are accessible to H-mode, but not to S-mode.

\subsection{Background Supervisor Status ({\tt bsstatus}) Register}

The {\tt sstatus} register is an XLEN-bit read/write register formatted as
shown in Figure~\ref{bsstatusreg}.  When V=0, the {\tt bsstatus} register
holds the S-mode guest's version of several fields of the {\tt sstatus}
register: UXL, MXR, SUM, FS, SPP, SPIE, and SIE.  When V=1, {\tt bsstatus}
holds H-mode's version of these fields.  When transitioning between
virtualization modes (V=0 to V=1, or vice-versa), the implementation swaps
these fields in {\tt bsstatus} with their counterparts in {\tt sstatus}.  The
other fields in {\tt sstatus} are unchanged.

When V=0, {\tt bsstatus} does not affect the behavior of the machine,
unless the MPRV feature in the {\tt mstatus} register or the SPRV feature
in the {\tt hstatus} register is used to execute a load or store
{\em as though} V=1.

\begin{figure*}[h!]
{\footnotesize
\begin{center}
\setlength{\tabcolsep}{4pt}
\begin{tabular}{McEccc}
\\
\instbitrange{XLEN-1}{34} &
\instbitrange{33}{32} &
\instbitrange{31}{20} &
\instbit{19} &
\instbit{18} &
 \\
\hline
\multicolumn{1}{|c|}{\wpri} &
\multicolumn{1}{c|}{UXL} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{MXR} &
\multicolumn{1}{c|}{SUM} &
 \\
\hline
XLEN-34 & 2 & 12 & 1 & 1 & \\
\end{tabular}
\begin{tabular}{cFFYcWcFcc}
\\
&
\instbitrange{17}{15} &
\instbitrange{14}{13} &
\instbitrange{12}{9} &
\instbit{8} &
\instbitrange{7}{6} &
\instbit{5} &
\instbitrange{4}{2} &
\instbit{1} &
\instbit{0} \\
\hline
 &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{FS[1:0]} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{SPP} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{SPIE} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{SIE} &
\multicolumn{1}{c|}{\wpri} \\
\hline
 & 3 & 2 & 4 & 1 & 2 & 1 & 3 & 1 & 1 \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Background supervisor status register ({\tt bsstatus}) for RV64 and RV128.}
\label{bsstatusreg}
\end{figure*}

\subsection{Background Supervisor Interrupt Registers ({\tt sip} and {\tt sie})}

The {\tt bsip} register is an XLEN-bit read/write register formatted as shown
in Figure~\ref{bsipreg}.  When V=0, the {\tt bsip} register holds the S-mode
guest's version of the {\tt sip} register.  When V=1, {\tt bsip} holds
H-mode's version of the {\tt sip} register.  When transitioning between
virtualization modes (V=0 to V=1, or vice-versa), the implementation swaps the
contents of {\tt bsip} and {\tt sip}.

\note{AW: Need to describe how {\tt bsip}.SEIP interacts with PLIC.  I think {\tt bsip}.SEIP should purely be a read-write storage bit to emulate the PLIC for S-mode; the PLIC should not be wired into {\tt bsip}.SEIP.}

\begin{figure*}[h!]
{\footnotesize
\begin{center}
\setlength{\tabcolsep}{4pt}
\begin{tabular}{TcFcFcc}
\instbitrange{XLEN-1}{10} &
\instbit{9} &
\instbitrange{8}{6} &
\instbit{5} &
\instbitrange{4}{2} &
\instbit{1} &
\instbit{0} \\
\hline
\multicolumn{1}{|c|}{\wiri} &
\multicolumn{1}{c|}{SEIP} &
\multicolumn{1}{c|}{\wiri} &
\multicolumn{1}{c|}{STIP} &
\multicolumn{1}{c|}{\wiri} &
\multicolumn{1}{c|}{SSIP} &
\multicolumn{1}{c|}{\wiri} \\
\hline
XLEN-10 & 1 & 3 & 1 & 3 & 1 & 1 \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Background supervisor interrupt-pending register ({\tt bsip}).}
\label{bsipreg}
\end{figure*}

The {\tt bsie} register is an XLEN-bit read/write register formatted as shown
in Figure~\ref{bsiereg}.  When V=0, the {\tt bsie} register holds the S-mode
guest's version of the {\tt sie} register.  When V=1, {\tt bsie} holds
H-mode's version of the {\tt sie} register.  When transitioning between
virtualization modes (V=0 to V=1, or vice-versa), the implementation swaps the
contents of {\tt bsie} and {\tt sie}.

\begin{figure*}[h!]
{\footnotesize
\begin{center}
\setlength{\tabcolsep}{4pt}
\begin{tabular}{TcFcFcc}
\instbitrange{XLEN-1}{10} &
\instbit{9} &
\instbitrange{8}{6} &
\instbit{5} &
\instbitrange{4}{2} &
\instbit{1} &
\instbit{0} \\
\hline
\multicolumn{1}{|c|}{\wpri} &
\multicolumn{1}{c|}{SEIE} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{STIE} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{SSIE} &
\multicolumn{1}{c|}{\wiri} \\
\hline
XLEN-10 & 1 & 3 & 1 & 3 & 1 & 1 \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Background supervisor interrupt-enable register ({\tt bsie}).}
\label{bsiereg}
\end{figure*}

When V=0, {\tt bsip} and {\tt bsie} do not affect the behavior of the machine.
When V=1, they hold the active interrupt-pending and interrupt-enable bits,
respectively, for H-mode; if any bit position holds a 1 in both registers, an
interrupt will be taken.

\begin{commentary}
The {\tt bsip} and {\tt bsie} CSRs do not hold copies of the user-mode
interrupt fields.  The expectation is that the context-switch code
will swap the {\tt uip} and {\tt uie} CSRs
along with the other user-mode interrupt
registers ({\tt ustatus}, {\tt utvec}, etc.) if that feature is enabled.
\end{commentary}

\subsection{Background Supervisor Trap Vector Base Address Register ({\tt bstvec})}

The {\tt stvec} register is an XLEN-bit read/write register formatted as shown
in Figure~\ref{bstvecreg}.  When V=0, the {\tt bstvec} register holds the
S-mode guest's version of the {\tt stvec} register.  When V=1, {\tt bstvec}
holds H-mode's version of the {\tt stvec} register.  When transitioning between
virtualization modes (V=0 to V=1, or vice-versa), the implementation swaps the
contents of {\tt bstvec} and {\tt stvec}.

When V=0, {\tt bstvec} does not affect the behavior of the machine.  When V=1,
it controls the value to which the {\tt pc} will be set upon a trap into
H-mode.

\begin{figure*}[h!]
{\footnotesize
\begin{center}
\begin{tabular}{J@{}R}
\instbitrange{XLEN-1}{2} &
\instbitrange{1}{0} \\
\hline
\multicolumn{1}{|c|}{BASE[XLEN-1:2] (\warl)} & 
\multicolumn{1}{c|}{MODE (\warl)} \\
\hline
XLEN-2 & 2 \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Background supervisor trap vector base address register ({\tt bstvec}).}
\label{bstvecreg}
\end{figure*}

\section{Exceptions}

The hypervisor extension modifies the environment-call exception cause
encoding.  Environment calls from H-mode use cause 9, whereas environment
calls from an S-mode guest now use cause 10.  Table~\ref{hcauses} lists the
possible M-mode and H-mode exception codes when the hypervisor extension is
present.

\begin{commentary}
Without the hypervisor extension, cause 9 is used for S-mode environment
calls.  Using cause 9 for H-mode environment calls when the hypervisor
extension is enabled allows the same M-mode software to work with or
without the hypervisor extension.
\end{commentary}

\begin{table*}[h!]
\begin{center}
\begin{tabular}{|r|r|l|l|}

  \hline
  Interrupt & Exception Code  & Description \\
  \hline	 
  1         & 0               & User software interrupt \\
  1         & 1               & Supervisor software interrupt \\
  1         & 2--3            & {\em Reserved} \\
  1         & 4               & User timer interrupt \\
  1         & 5               & Supervisor timer interrupt \\
  1         & 6--7            & {\em Reserved} \\
  1         & 8               & User external interrupt \\
  1         & 9               & Supervisor external interrupt \\
  1         & $\ge$10         & {\em Reserved} \\ \hline
  0         & 0               & Instruction address misaligned \\
  0         & 1               & Instruction access fault \\
  0         & 2               & Illegal instruction \\   
  0         & 3               & Breakpoint \\
  0         & 4               & Load address misaligned \\
  0         & 5               & Load access fault \\
  0         & 6               & Store/AMO address misaligned \\
  0         & 7               & Store/AMO access fault \\
  0         & 8               & Environment call from U-mode \\
  0         & 9               & Environment call from H-mode \\
  0         & 10              & Environment call from S-mode \\
  0         & 11              & {\em Reserved} \\
  0         & 12              & Instruction page fault \\
  0         & 13              & Load page fault \\
  0         & 14              & {\em Reserved} \\
  0         & 15              & Store/AMO page fault \\
  0         & $\ge$16         & {\em Reserved} \\
  \hline
\end{tabular}
\end{center}
\caption{Supervisor and machine cause register ({\tt scause} and {\tt mcause}) values when hypervisor extension is enabled.}
\label{hcauses}
\end{table*}

\section{Machine-Level CSRs}

The hypervisor extension adds one new machine-level CSR, {\tt mvtval}, and
augments the {\tt mstatus} CSR.

\subsection{Machine Virtual Trap Value ({\tt mvtval}) Register}

The {\tt mvtval} register is an XLEN-bit read-write register formatted as shown
in Figure~\ref{mvtvalreg}.  When an access fault, page fault, or misaligned
address exception is taken into M-mode, {\tt mvtval} is
written with the original virtual address that caused the exception.
For other traps into M-mode, {\tt mvtval} is written with zero.

\begin{figure}[h!]
{\footnotesize
\begin{center}
\begin{tabular}{@{}J}
\instbitrange{XLEN-1}{0} \\
\hline
\multicolumn{1}{|c|}{\tt mvtval} \\
\hline
XLEN \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Machine Virtual Trap Value register.}
\label{mvtvalreg}
\end{figure}

\subsection{Machine Status Register ({\tt mstatus})}

The hypervisor extension adds two fields to the machine-mode {\tt mstatus} CSR
and modifies the behavior of some of the existing fields.
Figure~\ref{hypervisor-mstatus} shows the {\tt mstatus} register when the
hypervisor extension is provided.

\begin{figure*}[h!]
{\footnotesize
\begin{center}
\setlength{\tabcolsep}{4pt}
\begin{tabular}{cYccYccccccc}
\\
\instbit{XLEN-1} &
\instbitrange{XLEN-2}{36} &
\instbitrange{35}{34} &
\instbitrange{33}{32} &
\instbitrange{31}{23} &
\instbit{22} &
\instbit{21} &
\instbit{20} &
\instbit{19} &
\instbit{18} &
\instbit{17} &
 \\
\hline
\multicolumn{1}{|c|}{SD} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{SXL[1:0]} &
\multicolumn{1}{c|}{UXL[1:0]} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{TSR} &
\multicolumn{1}{c|}{TW} &
\multicolumn{1}{c|}{TVM} &
\multicolumn{1}{c|}{MXR} &
\multicolumn{1}{c|}{SUM} &
\multicolumn{1}{c|}{MPRV} &
 \\
\hline
1 & XLEN-37 & 2 & 2 & 9 & 1 & 1 & 1 & 1 & 1 & 1 & \\
\end{tabular}
\begin{tabular}{ccccccccccccccc}
\\
&
\instbitrange{16}{15} &
\instbitrange{14}{13} &
\instbitrange{12}{11} &
\instbit{10} &
\instbit{9} &
\instbit{8} &
\instbit{7} &
\instbit{6} &
\instbit{5} &
\instbit{4} &
\instbit{3} &
\instbit{2} &
\instbit{1} &
\instbit{0} \\
\hline
 &
\multicolumn{1}{|c|}{XS[1:0]} &
\multicolumn{1}{c|}{FS[1:0]} &
\multicolumn{1}{c|}{MPP[1:0]} &
\multicolumn{1}{c|}{MPV} &
\multicolumn{1}{c|}{MTL} &
\multicolumn{1}{c|}{SPP} &
\multicolumn{1}{c|}{MPIE} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{SPIE} &
\multicolumn{1}{c|}{UPIE} &
\multicolumn{1}{c|}{MIE} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{SIE} &
\multicolumn{1}{c|}{UIE} \\
\hline
 & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Machine-mode status register ({\tt mstatus}) for RV64 and RV128.}
\label{hypervisor-mstatus}
\end{figure*}

The MPV bit (Machine Previous Virtualization Mode) is written by the implementation
whenever a trap is taken into M-mode.  Just as the MPP bit is set to the privilege
mode at the time of the trap, the MPV bit is set to the value of the virtualization
mode V at the time of the trap.  When an MRET instruction is executed, the
virtualization mode V is set to MPV.

The MTL bit (Machine Translation Level), which indicates which address-translation level
caused a page-fault exception, is also written by the implementation whenever a trap
is taken into M-mode.  On an access fault, or on a page-fault due to H-mode address
translation, MTL is set to 0.  For any other trap into M-mode, MTL is set to the value
of V at the time of the trap.

The SXL field controls the value of XLEN for H-mode.
The UXL field controls the value of XLEN for S-mode when V=1, or for U-mode when V=0.

The TSR and TVM fields only affect execution in H-mode.

The TW field affect execution in both H-mode and S-mode.

The hypervisor extension changes the behavior of the the Modify Privilege
field, MPRV.  When MPRV=0, translation and protection behave as normal.  When
MPRV=1, loads and stores are translated and protected as though the current
privilege mode were set to MPP and the current virtualization mode were set to
MPV.  Table~\ref{h-mprv} enumerates the cases.

\begin{table*}[h!]
\begin{center}
\begin{tabular}{|c|c|c||p{5in}|}
  \hline
   MPRV & MPP & MPV & Effect \\ \hline \hline
   0    & --  & -- & M-level access with no translation. \\ \hline
   1    & M   & -- & M-level access with no translation. \\ \hline
   1    & U   & 0  & U-level access with H-level translation and protection only. \\ \hline
   1    & S   & 0  & H-level access with H-level translation and protection only.  {\tt hstatus}.SPRV can modify effective privilege (see Table~\ref{h-sprv}). \\ \hline
   1    & U   & 1  & U-level access with two-level translation and protection. {\tt sstatus}.MXR makes any executable page readable.  {\tt bsstatus}.MXR makes readable those pages marked executable at the S-mode translation level only if readable at the H-mode translation level. \\ \hline
   1    & S   & 1  & S-level access with two-level translation and protection. {\tt sstatus}.MXR makes any executable page readable.  {\tt bsstatus}.MXR makes readable those pages marked executable at the S-mode translation level only if readable at the H-mode translation level. {\tt bsstatus}.SUM applies instead of {\tt sstatus}.SUM. \\ \hline
 \end{tabular}
\end{center}
\caption{Effect on load and store translation and protection under MPRV.}
\label{h-mprv}
\end{table*}
