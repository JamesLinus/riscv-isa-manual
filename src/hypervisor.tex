\chapter{Hypervisor Extension, Version 0.0}
\label{hypervisor}

This chapter describes the RISC-V hypervisor extension, which virtualizes the
supervisor-level architecture to efficiently host guest operating systems atop
a type-1 or type-2 hypervisor.  The hypervisor extension adds a second level
of address translation, from supervisor-physical addresses to
hypervisor-physical addresses, to virtualize the memory and memory-mapped I/O
subsystems.  The hypervisor extension also adds a new privilege mode, {\em
hypervisor mode} (H-mode), where the hypervisor runs.  H-mode acts the same as
S-mode, but with additional instructions and CSRs that control second-level
address translation and support hosting an S-mode guest.  Existing S-mode
operating systems can execute without modification either in H-mode or as
S-mode guests.

An H-mode OS or hypervisor interacts with the machine through the same SBI
as would an S-mode OS.  An H-mode hypervisor is expected to implement the
SBI for its S-mode guest.

\begin{commentary}
The privileged architecture is designed to simplify the use of classic
virtualization techniques, where a guest OS is run at user-level, as
the few privileged instructions can be easily detected and trapped.
The hypervisor extension improves virtualization performance by
reducing the frequency of these traps.
\end{commentary}

The hypervisor extensions are enabled by setting bit 7 in the {\tt misa} CSR,
which corresponds to the letter H.  When {\tt misa}[7] is clear, the hart
behaves as though this extension were not implemented, and attempts to use
hypervisor CSRs or instructions raise an illegal instruction exception.

\section{Privilege Modes}

The current {\em virtualization mode}, denoted V, indicates whether the hart
is currently executing in a guest.  When V=1, the hart is either in S-mode, or
in U-mode under an S-mode OS.  When V=0, the hart is either in M-mode, in
H-mode, or in U-mode under an H-mode OS.  The virtualization mode also
indicates whether two-level address translation is active (V=1) or inactive
(V=0).  Table~\ref{h-operating-modes} lists the possible operating modes of
a RISC-V hart with the hypervisor extension.

\begin{table*}[h!]
\begin{center}
\begin{tabular}{|c|c||l|l|l|}
  \hline
   Privilege & Virtualization & \multirow{2}{*}{Abbreviation} & \multirow{2}{*}{Name} & Two-Level \\
   Mode      & Mode (V)       &                               &                       & Translation \\ \hline
   U         & 0              & U-mode  & User mode & Off \\
   S         & 0              & H-mode  & Hypervisor mode & Off \\
   M         & 0              & M-mode  & Machine mode & Off \\
   U         & 1              & U-mode  & User mode & On \\
   S         & 1              & S-mode  & Supervisor mode & On \\
  \hline
 \end{tabular}
\end{center}
\caption{Operating modes with the hypervisor extension.}
\label{h-operating-modes}
\end{table*}

\section{Hypervisor CSRs}

An H-mode hypervisor uses the S-mode CSRs to interact with the exception,
interrupt, and address-translation subsystems.
Additional CSRs are provided to H-mode, but not to S-mode, to control
the behavior of an S-mode guest:
{\tt hvtval}, {\tt hstatus}, {\tt hedeleg}, and
{\tt hideleg}.

Additionally, several {\em background} supervisor CSRs are copies of one of
the existing {\em foreground} supervisor CSRs.  For example, the {\tt
bsstatus} CSR is the background copy of the foreground {\tt sstatus} CSR.
When transitioning between virtualization modes (V=0 to V=1, or vice-versa),
the implementation swaps the background supervisor CSRs with their foreground
counterparts.  When V=0, the background supervisor CSRs contain the S-mode
guest's version of those CSRs, and the foreground supervisor CSRs contain
H-mode's version.  When V=1, the background supervisor CSRs contain H-mode's
version, and the foreground supervisor CSRs contain the S-mode guest's
version.  The background registers are accessible to H-mode, but not to S-mode.

\subsection{Hypervisor Virtual Trap Value ({\tt hvtval}) Register}

The {\tt hvtval} register is an XLEN-bit read-write register formatted as shown
in Figure~\ref{hvtvalreg}.  When an access fault, page fault, or misaligned
address exception is taken into H-mode, {\tt hvtval} is
written with the original virtual address that caused the exception.
For other traps into H-mode, {\tt hvtval} is written with zero.

\begin{figure}[h!]
{\footnotesize
\begin{center}
\begin{tabular}{@{}J}
\instbitrange{XLEN-1}{0} \\
\hline
\multicolumn{1}{|c|}{\tt hvtval} \\
\hline
XLEN \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Hypervisor virtual trap value register ({\tt hvtval}).}
\label{hvtvalreg}
\end{figure}

\subsection{Hypervisor Status ({\tt hstatus}) Register}

The {\tt hstatus} register is an XLEN-bit read/write register
formatted as shown in Figure~\ref{hstatusreg}.  The {\tt hstatus}
register provides facilities analogous to the {\tt mstatus} register
that track and control the exception behavior of an S-mode guest.

\begin{figure*}[h!]
{\footnotesize
\begin{center}
\setlength{\tabcolsep}{4pt}
\begin{tabular}{EcccWcYccR}
\\
\instbitrange{XLEN-1}{23} &
\instbit{22} &
\instbit{21} &
\instbit{20} &
\instbitrange{19}{18} &
\instbit{17} &
\instbitrange{16}{11} &
\instbit{10} &
\instbit{9} &
\instbitrange{8}{0} \\
\hline
\multicolumn{1}{|c|}{\wpri} &
\multicolumn{1}{c|}{TSR} &
\multicolumn{1}{c|}{TW} &
\multicolumn{1}{c|}{TVM} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{SPRV} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{SPV} &
\multicolumn{1}{c|}{STL} &
\multicolumn{1}{c|}{\wpri} \\
\hline
XLEN-23 & 1 & 1 & 1 & 2 & 1 & 6 & 1 & 1 & 9 \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Hypervisor-mode status register ({\tt hstatus}).}
\label{hstatusreg}
\end{figure*}

The {\tt hstatus} fields TSR, TW, and TVM are defined analogously to the
homonymous fields in {\tt mstatus}, but affect the trapping behavior of the
SRET, WFI, and virtual-memory management instructions in the S-mode guest
only.

The SPV bit (Supervisor Previous Virtualization Mode) is written by the implementation
whenever a trap is taken into H-mode.  Just as the SPP bit in {\tt sstatus} is set to the privilege
mode at the time of the trap, the SPV bit in {\tt hstatus} is set to the value of the virtualization
mode V at the time of the trap.  When an SRET instruction is executed when V=0,
V is set to SPV.

The STL bit (Supervisor Translation Level), which indicates which address-translation level
caused a page-fault exception, is also written by the implementation whenever a trap
is taken into H-mode.  On an access fault, or on a page-fault due to H-mode address
translation, STL is set to 0.  For any other trap into H-mode, STL is set to the value
of V at the time of the trap.

The SPRV bit modifies the privilege with which loads and stores execute.
When SPRV=0, translation and protection behave as normal.  When SPRV=1,
load and store memory addresses are translated and protected as though
the current privilege mode were set to {\tt sstatus}.SPP and the current
virtualization mode were set to {\tt hstatus}.SPV.
Table~\ref{h-sprv} enumerates the cases.

\begin{commentary}
For simplicity, SPRV is in effect even when in S-mode or U-mode, but in normal
use will only be enabled for short sequences in H-mode.
\end{commentary}

\begin{table*}[h!]
\begin{center}
\begin{tabular}{|c|c|c||p{5in}|}
  \hline
   SPRV & SPP & SPV & Effect \\ \hline \hline
   0    & --  & -- & Normal access; current privilege and virtualization modes apply. \\ \hline
   1    & 0   & 0  & U-level access with H-level translation and protection only. \\ \hline
   1    & 1   & 0  & H-level access with H-level translation and protection only. \\ \hline
   1    & 0   & 1  & U-level access with two-level translation and protection. {\tt sstatus}.MXR makes any executable page readable.  {\tt bsstatus}.MXR makes readable those pages marked executable at the S-mode translation level only if readable at the H-mode translation level. \\ \hline
   1    & 1   & 1  & S-level access with two-level translation and protection. {\tt sstatus}.MXR makes any executable page readable.  {\tt bsstatus}.MXR makes readable those pages marked executable at the S-mode translation level only if readable at the H-mode translation level. {\tt bsstatus}.SUM applies instead of {\tt sstatus}.SUM. \\ \hline
 \end{tabular}
\end{center}
\caption{Effect on load and store translation and protection under SPRV.}
\label{h-sprv}
\end{table*}

\subsection{Hypervisor Trap Delegation Registers ({\tt hedeleg} and {\tt hideleg})}

By default, all traps at any privilege level are handled in M-mode, though
M-mode usually uses the {\tt medeleg} and {\tt mideleg} CSRs to delegate
some traps to H-mode.  The {\tt hedeleg} and {\tt hideleg} CSRs allow these
traps to be further delegated to an S-mode guest; their layout is the same
as {\tt medeleg} and {\tt mideleg}.

\begin{figure}[h!]
{\footnotesize
\begin{center}
\begin{tabular}{@{}U}
\instbitrange{XLEN-1}{0} \\
\hline
\multicolumn{1}{|c|}{Synchronous Exceptions (\warl)} \\
\hline
XLEN \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Hypervisor Exception Delegation Register {\tt hedeleg}.}
\label{hedelegreg}
\end{figure}

\begin{figure}[h!]
{\footnotesize
\begin{center}
\begin{tabular}{@{}U}
\instbitrange{XLEN-1}{0} \\
\hline
\multicolumn{1}{|c|}{Interrupts (\warl)} \\
\hline
XLEN \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Hypervisor Interrupt Delegation Register {\tt hideleg}.}
\label{hidelegreg}
\end{figure}

The {\tt hedeleg} and {\tt hideleg} registers are only active when V=1.  When
V=1, any trap that has been delegated to H-mode (using {\tt medeleg} or {\tt
mideleg}) is further delegated to S-mode if the corresponding {\tt hedeleg} or
{\tt hideleg} bit is set.  If the N extension for user-mode interrupts
is implemented, the S-mode guest may further delegate the interrupt
to U-mode by setting the corresponding bit in {\tt sedeleg} or {\tt sideleg}.

When V=0 and the N extension for user-mode interrupts is implemented, any trap
that has been delegated to H-mode can be further delegated to U-mode by
setting the corresponding bit in {\tt sedeleg} or {\tt sideleg}.

\subsection{Background Supervisor Status ({\tt bsstatus}) Register}

The {\tt sstatus} register is an XLEN-bit read/write register formatted as
shown in Figure~\ref{bsstatusreg}.  When V=0, the {\tt bsstatus} register
holds the S-mode guest's version of several fields of the {\tt sstatus}
register: UXL, MXR, SUM, FS, SPP, SPIE, and SIE.  When V=1, {\tt bsstatus}
holds H-mode's version of these fields.  When transitioning between
virtualization modes (V=0 to V=1, or vice-versa), the implementation swaps
these fields in {\tt bsstatus} with their counterparts in {\tt sstatus}.  The
other fields in {\tt sstatus} are unchanged.

When V=0, {\tt bsstatus} does not directly affect the behavior of the machine,
unless the MPRV feature in the {\tt mstatus} register or the SPRV feature
in the {\tt hstatus} register is used to execute a load or store
{\em as though} V=1.

\begin{figure*}[h!]
{\footnotesize
\begin{center}
\setlength{\tabcolsep}{4pt}
\begin{tabular}{McEccc}
\\
\instbitrange{XLEN-1}{34} &
\instbitrange{33}{32} &
\instbitrange{31}{20} &
\instbit{19} &
\instbit{18} &
 \\
\hline
\multicolumn{1}{|c|}{\wpri} &
\multicolumn{1}{c|}{UXL} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{MXR} &
\multicolumn{1}{c|}{SUM} &
 \\
\hline
XLEN-34 & 2 & 12 & 1 & 1 & \\
\end{tabular}
\begin{tabular}{cFFYcWcFcc}
\\
&
\instbitrange{17}{15} &
\instbitrange{14}{13} &
\instbitrange{12}{9} &
\instbit{8} &
\instbitrange{7}{6} &
\instbit{5} &
\instbitrange{4}{2} &
\instbit{1} &
\instbit{0} \\
\hline
 &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{FS[1:0]} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{SPP} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{SPIE} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{SIE} &
\multicolumn{1}{c|}{\wpri} \\
\hline
 & 3 & 2 & 4 & 1 & 2 & 1 & 3 & 1 & 1 \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Background supervisor status register ({\tt bsstatus}) for RV64 and RV128.}
\label{bsstatusreg}
\end{figure*}

\subsection{Background Supervisor Interrupt Registers ({\tt bsip} and {\tt bsie})}

The {\tt bsip} register is an XLEN-bit read/write register formatted as shown
in Figure~\ref{bsipreg}.  When V=0, the {\tt bsip} register holds the S-mode
guest's version of the {\tt sip} register.  When V=1, {\tt bsip} holds
H-mode's version of the {\tt sip} register.  When transitioning between
virtualization modes (V=0 to V=1, or vice-versa), the implementation swaps the
contents of {\tt bsip} and {\tt sip}.

\note{AW: Need to describe how {\tt bsip}.SEIP interacts with PLIC.  I think {\tt bsip}.SEIP should purely be a read-write storage bit to emulate the PLIC for S-mode; the PLIC should not be wired into {\tt bsip}.SEIP.}

\begin{figure*}[h!]
{\footnotesize
\begin{center}
\setlength{\tabcolsep}{4pt}
\begin{tabular}{TcFcFcc}
\instbitrange{XLEN-1}{10} &
\instbit{9} &
\instbitrange{8}{6} &
\instbit{5} &
\instbitrange{4}{2} &
\instbit{1} &
\instbit{0} \\
\hline
\multicolumn{1}{|c|}{\wiri} &
\multicolumn{1}{c|}{SEIP} &
\multicolumn{1}{c|}{\wiri} &
\multicolumn{1}{c|}{STIP} &
\multicolumn{1}{c|}{\wiri} &
\multicolumn{1}{c|}{SSIP} &
\multicolumn{1}{c|}{\wiri} \\
\hline
XLEN-10 & 1 & 3 & 1 & 3 & 1 & 1 \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Background supervisor interrupt-pending register ({\tt bsip}).}
\label{bsipreg}
\end{figure*}

The {\tt bsie} register is an XLEN-bit read/write register formatted as shown
in Figure~\ref{bsiereg}.  When V=0, the {\tt bsie} register holds the S-mode
guest's version of the {\tt sie} register.  When V=1, {\tt bsie} holds
H-mode's version of the {\tt sie} register.  When transitioning between
virtualization modes (V=0 to V=1, or vice-versa), the implementation swaps the
contents of {\tt bsie} and {\tt sie}.

\begin{figure*}[h!]
{\footnotesize
\begin{center}
\setlength{\tabcolsep}{4pt}
\begin{tabular}{TcFcFcc}
\instbitrange{XLEN-1}{10} &
\instbit{9} &
\instbitrange{8}{6} &
\instbit{5} &
\instbitrange{4}{2} &
\instbit{1} &
\instbit{0} \\
\hline
\multicolumn{1}{|c|}{\wpri} &
\multicolumn{1}{c|}{SEIE} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{STIE} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{SSIE} &
\multicolumn{1}{c|}{\wiri} \\
\hline
XLEN-10 & 1 & 3 & 1 & 3 & 1 & 1 \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Background supervisor interrupt-enable register ({\tt bsie}).}
\label{bsiereg}
\end{figure*}

When V=0, {\tt bsip} and {\tt bsie} do not affect the behavior of the machine.
When V=1, they hold the active interrupt-pending and interrupt-enable bits,
respectively, for H-mode; if any bit position holds a 1 in both registers, an
interrupt will be taken.

\begin{commentary}
The {\tt bsip} and {\tt bsie} CSRs do not hold copies of the user-mode
interrupt fields.  The expectation is that the context-switch code
will swap the {\tt uip} and {\tt uie} CSRs
along with the other user-mode interrupt
registers ({\tt ustatus}, {\tt utvec}, etc.) if that feature is enabled.
\end{commentary}

\subsection{Background Supervisor Trap Vector Base Address Register ({\tt bstvec})}

The {\tt bstvec} register is an XLEN-bit read/write register formatted as shown
in Figure~\ref{bstvecreg}.  When V=0, the {\tt bstvec} register holds the
S-mode guest's version of the {\tt stvec} register.  When V=1, {\tt bstvec}
holds H-mode's version of the {\tt stvec} register.  When transitioning between
virtualization modes (V=0 to V=1, or vice-versa), the implementation swaps the
contents of {\tt bstvec} and {\tt stvec}.

When V=0, {\tt bstvec} does not directly affect the behavior of the machine.  When V=1,
it controls the value to which the {\tt pc} will be set upon a trap into
H-mode.

\begin{figure*}[h!]
{\footnotesize
\begin{center}
\begin{tabular}{J@{}R}
\instbitrange{XLEN-1}{2} &
\instbitrange{1}{0} \\
\hline
\multicolumn{1}{|c|}{BASE[XLEN-1:2] (\warl)} & 
\multicolumn{1}{c|}{MODE (\warl)} \\
\hline
XLEN-2 & 2 \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Background supervisor trap vector base address register ({\tt bstvec}).}
\label{bstvecreg}
\end{figure*}

\subsection{Background Supervisor Scratch Register ({\tt bsscratch})}

The {\tt bsscratch} register is an XLEN-bit read/write register formatted as shown
in Figure~\ref{bsscratchreg}.  When V=0, the {\tt bsscratch} register holds the
S-mode guest's version of the {\tt sscratch} register.  When V=1, {\tt bsscratch}
holds H-mode's version of the {\tt sscratch} register.  When transitioning between
virtualization modes (V=0 to V=1, or vice-versa), the implementation swaps the
contents of {\tt bsscratch} and {\tt sscratch}.

Typically, {\tt bsscratch} is used to hold a pointer to the hart-local
hypervisor context (when V=1) or supervisor context (when V=0).  The
contents of {\tt bsscratch} do not directly affect the behavior of
the machine.

\begin{figure*}[h!]
{\footnotesize
\begin{center}
\begin{tabular}{@{}J}
\instbitrange{XLEN-1}{0} \\
\hline
\multicolumn{1}{|c|}{\tt bsscratch} \\
\hline
XLEN \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Background supervisor scratch register ({\tt bsscratch}).}
\label{bsscratchreg}
\end{figure*}

\subsection{Background Supervisor Exception Program Counter ({\tt bsepc})}

The {\tt bsepc} register is an XLEN-bit read/write register formatted as shown
in Figure~\ref{bsepcreg}.  When V=0, the {\tt bsepc} register holds the
S-mode guest's version of the {\tt sepc} register.  When V=1, {\tt bsepc}
holds H-mode's version of the {\tt sepc} register.  When transitioning between
virtualization modes (V=0 to V=1, or vice-versa), the implementation swaps the
contents of {\tt bsepc} and {\tt sepc}.

The contents of {\tt bsepc} do not directly affect the behavior of
the machine.

{\tt bsepc} is a \warl\ register that must be able to hold the same set of
values that {\tt sepc} can hold.

\begin{figure*}[h!]
{\footnotesize
\begin{center}
\begin{tabular}{@{}J}
\instbitrange{XLEN-1}{0} \\
\hline
\multicolumn{1}{|c|}{\tt bsepc} \\
\hline
XLEN \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Background supervisor exception program counter ({\tt bsepc}).}
\label{bsepcreg}
\end{figure*}

\subsection{Background Supervisor Cause Register ({\tt bscause})}

The {\tt bscause} register is an XLEN-bit read/write register formatted as shown
in Figure~\ref{bscausereg}.  When V=0, the {\tt bscause} register holds the
S-mode guest's version of the {\tt scause} register.  When V=1, {\tt bscause}
holds H-mode's version of the {\tt scause} register.  When transitioning between
virtualization modes (V=0 to V=1, or vice-versa), the implementation swaps the
contents of {\tt bscause} and {\tt scause}.

The contents of {\tt bscause} do not directly affect the behavior of
the machine.

{\tt bscause} is a \wlrl\ register that must be able to hold the same set of
values that {\tt scause} can hold.

\begin{figure*}[h!]
{\footnotesize
\begin{center}
\begin{tabular}{c@{}U}
\instbit{XLEN-1} &
\instbitrange{XLEN-2}{0} \\
\hline
\multicolumn{1}{|c|}{Interrupt} &
\multicolumn{1}{c|}{Exception Code (\wlrl)} \\
\hline
1 & XLEN-1 \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Background supervisor cause register ({\tt bscause}).}
\label{bscausereg}
\end{figure*}

\subsection{Background Supervisor Trap Value Register ({\tt bstval})}

The {\tt bstval} register is an XLEN-bit read/write register formatted as shown
in Figure~\ref{bstvalreg}.  When V=0, the {\tt bstval} register holds the
S-mode guest's version of the {\tt stval} register.  When V=1, {\tt bstval}
holds H-mode's version of the {\tt stval} register.  When transitioning between
virtualization modes (V=0 to V=1, or vice-versa), the implementation swaps the
contents of {\tt bstval} and {\tt stval}.

The contents of {\tt bstval} do not directly affect the behavior of
the machine.

{\tt bstval} is a \warl\ register that must be able to hold the same set of
values that {\tt stval} can hold.

\begin{figure*}[h!]
{\footnotesize
\begin{center}
\begin{tabular}{@{}J}
\instbitrange{XLEN-1}{0} \\
\hline
\multicolumn{1}{|c|}{\tt bstval} \\
\hline
XLEN \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Background supervisor trap value register ({\tt bstval}).}
\label{bstvalreg}
\end{figure*}

\subsection{Background Address Translation and Protection Register ({\tt bsatp})}

The {\tt bsatp} register is an XLEN-bit read/write register formatted as shown
in Figure~\ref{bsatpreg}.  When V=0, the {\tt bsatp} register holds the
S-mode guest's version of the {\tt satp} register.  When V=1, {\tt bsatp}
holds H-mode's version of the {\tt satp} register.  When transitioning between
virtualization modes (V=0 to V=1, or vice-versa), the implementation swaps the
contents of {\tt bsatp} and {\tt satp}.

When V=0, {\tt bsatp} does not directly affect the behavior of the machine.  When V=1,
it controls the translation of supervisor-physical addresses to
hypervisor-phsyical addresses.  The interpretation of the MODE, ASID, and PPN
fields is the same as for {\tt satp}.

\begin{figure*}[h!]
{\footnotesize
\begin{center}
\begin{tabular}{@{}S@{}T@{}U}
\instbitrange{63}{60} &
\instbitrange{59}{44} &
\instbitrange{43}{0} \\
\hline
\multicolumn{1}{|c|}{{\tt MODE} (\warl)} &
\multicolumn{1}{|c|}{{\tt ASID} (\warl)} &
\multicolumn{1}{|c|}{{\tt PPN}  (\warl)} \\
\hline
4 & 16 & 44 \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{RV64 background supervisor address translation and protection register {\tt satp}, for MODE
values Sv39 and Sv48.}
\label{bsatpreg}
\end{figure*}

\section{Exceptions}

The hypervisor extension modifies the environment-call exception cause
encoding.  Environment calls from H-mode use cause 9, whereas environment
calls from an S-mode guest now use cause 10.  Table~\ref{hcauses} lists the
possible M-mode and H-mode exception codes when the hypervisor extension is
present.

\begin{commentary}
Without the hypervisor extension, cause 9 is used for S-mode environment
calls.  Using cause 9 for H-mode environment calls when the hypervisor
extension is enabled allows the same M-mode software to work with or
without the hypervisor extension.
\end{commentary}

\begin{table*}[h!]
\begin{center}
\begin{tabular}{|r|r|l|l|}

  \hline
  Interrupt & Exception Code  & Description \\
  \hline	 
  1         & 0               & User software interrupt \\
  1         & 1               & Supervisor software interrupt \\
  1         & 2--3            & {\em Reserved} \\
  1         & 4               & User timer interrupt \\
  1         & 5               & Supervisor timer interrupt \\
  1         & 6--7            & {\em Reserved} \\
  1         & 8               & User external interrupt \\
  1         & 9               & Supervisor external interrupt \\
  1         & $\ge$10         & {\em Reserved} \\ \hline
  0         & 0               & Instruction address misaligned \\
  0         & 1               & Instruction access fault \\
  0         & 2               & Illegal instruction \\   
  0         & 3               & Breakpoint \\
  0         & 4               & Load address misaligned \\
  0         & 5               & Load access fault \\
  0         & 6               & Store/AMO address misaligned \\
  0         & 7               & Store/AMO access fault \\
  0         & 8               & Environment call from U-mode \\
  0         & 9               & Environment call from H-mode \\
  0         & 10              & Environment call from S-mode \\
  0         & 11              & {\em Reserved} \\
  0         & 12              & Instruction page fault \\
  0         & 13              & Load page fault \\
  0         & 14              & {\em Reserved} \\
  0         & 15              & Store/AMO page fault \\
  0         & $\ge$16         & {\em Reserved} \\
  \hline
\end{tabular}
\end{center}
\caption{Supervisor and machine cause register ({\tt scause} and {\tt mcause}) values when hypervisor extension is enabled.}
\label{hcauses}
\end{table*}

\section{Hypervisor Instructions}

The hypervisor extension adds one new instruction, HRET, which is valid only in
H-mode or M-mode, and when {\tt mstatus}.TSR=0.  HRET sets {\tt hstatus}.SPV=1,
then performs an SRET.

\begin{commentary}
As compared to setting {\tt hstatus}.SPV then executing SRET, HRET halves the
number of emulation traps when executing an H-mode hypervisor on an
implementation without hypervisor extensions, or when recursively
virtualizing.
\end{commentary}

\section{Machine-Level CSRs}

The hypervisor extension adds one new machine-level CSR, {\tt mvtval}, and
augments the {\tt mstatus} CSR.

\subsection{Machine Virtual Trap Value ({\tt mvtval}) Register}

The {\tt mvtval} register is an XLEN-bit read-write register formatted as shown
in Figure~\ref{mvtvalreg}.  When an access fault, page fault, or misaligned
address exception is taken into M-mode, {\tt mvtval} is
written with the original virtual address that caused the exception.
For other traps into M-mode, {\tt mvtval} is written with zero.

\begin{figure}[h!]
{\footnotesize
\begin{center}
\begin{tabular}{@{}J}
\instbitrange{XLEN-1}{0} \\
\hline
\multicolumn{1}{|c|}{\tt mvtval} \\
\hline
XLEN \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Machine Virtual Trap Value register ({\tt mvtval}).}
\label{mvtvalreg}
\end{figure}

\subsection{Machine Status Register ({\tt mstatus})}

The hypervisor extension adds two fields to the machine-mode {\tt mstatus} CSR
and modifies the behavior of some of the existing fields.
Figure~\ref{hypervisor-mstatus} shows the {\tt mstatus} register when the
hypervisor extension is provided.

\begin{figure*}[h!]
{\footnotesize
\begin{center}
\setlength{\tabcolsep}{4pt}
\begin{tabular}{cYccYccccccc}
\\
\instbit{XLEN-1} &
\instbitrange{XLEN-2}{36} &
\instbitrange{35}{34} &
\instbitrange{33}{32} &
\instbitrange{31}{23} &
\instbit{22} &
\instbit{21} &
\instbit{20} &
\instbit{19} &
\instbit{18} &
\instbit{17} &
 \\
\hline
\multicolumn{1}{|c|}{SD} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{SXL[1:0]} &
\multicolumn{1}{c|}{UXL[1:0]} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{TSR} &
\multicolumn{1}{c|}{TW} &
\multicolumn{1}{c|}{TVM} &
\multicolumn{1}{c|}{MXR} &
\multicolumn{1}{c|}{SUM} &
\multicolumn{1}{c|}{MPRV} &
 \\
\hline
1 & XLEN-37 & 2 & 2 & 9 & 1 & 1 & 1 & 1 & 1 & 1 & \\
\end{tabular}
\begin{tabular}{ccccccccccccccc}
\\
&
\instbitrange{16}{15} &
\instbitrange{14}{13} &
\instbitrange{12}{11} &
\instbit{10} &
\instbit{9} &
\instbit{8} &
\instbit{7} &
\instbit{6} &
\instbit{5} &
\instbit{4} &
\instbit{3} &
\instbit{2} &
\instbit{1} &
\instbit{0} \\
\hline
 &
\multicolumn{1}{|c|}{XS[1:0]} &
\multicolumn{1}{c|}{FS[1:0]} &
\multicolumn{1}{c|}{MPP[1:0]} &
\multicolumn{1}{c|}{MPV} &
\multicolumn{1}{c|}{MTL} &
\multicolumn{1}{c|}{SPP} &
\multicolumn{1}{c|}{MPIE} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{SPIE} &
\multicolumn{1}{c|}{UPIE} &
\multicolumn{1}{c|}{MIE} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{SIE} &
\multicolumn{1}{c|}{UIE} \\
\hline
 & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Machine-mode status register ({\tt mstatus}) for RV64 and RV128.}
\label{hypervisor-mstatus}
\end{figure*}

The MPV bit (Machine Previous Virtualization Mode) is written by the implementation
whenever a trap is taken into M-mode.  Just as the MPP bit is set to the privilege
mode at the time of the trap, the MPV bit is set to the value of the virtualization
mode V at the time of the trap.  When an MRET instruction is executed, the
virtualization mode V is set to MPV.

The MTL bit (Machine Translation Level), which indicates which address-translation level
caused a page-fault exception, is also written by the implementation whenever a trap
is taken into M-mode.  On an access fault, or on a page-fault due to H-mode address
translation, MTL is set to 0.  For any other trap into M-mode, MTL is set to the value
of V at the time of the trap.

The SXL field controls the value of XLEN for H-mode.
The UXL field controls the value of XLEN for S-mode when V=1, or for U-mode when V=0.

The TSR and TVM fields only affect execution in H-mode.

The TW field affect execution in both H-mode and S-mode.

The hypervisor extension changes the behavior of the the Modify Privilege
field, MPRV.  When MPRV=0, translation and protection behave as normal.  When
MPRV=1, loads and stores are translated and protected as though the current
privilege mode were set to MPP and the current virtualization mode were set to
MPV.  Table~\ref{h-mprv} enumerates the cases.

\begin{table*}[h!]
\begin{center}
\begin{tabular}{|c|c|c||p{5in}|}
  \hline
   MPRV & MPP & MPV & Effect \\ \hline \hline
   0    & --  & -- & Normal access; current privilege and virtualization modes apply. \\ \hline
   1    & M   & -- & M-level access with no translation. \\ \hline
   1    & U   & 0  & U-level access with H-level translation and protection only. \\ \hline
   1    & S   & 0  & H-level access with H-level translation and protection only.  \\ \hline
   1    & U   & 1  & U-level access with two-level translation and protection. {\tt sstatus}.MXR makes any executable page readable.  {\tt bsstatus}.MXR makes readable those pages marked executable at the S-mode translation level only if readable at the H-mode translation level. \\ \hline
   1    & S   & 1  & S-level access with two-level translation and protection. {\tt sstatus}.MXR makes any executable page readable.  {\tt bsstatus}.MXR makes readable those pages marked executable at the S-mode translation level only if readable at the H-mode translation level. {\tt bsstatus}.SUM applies instead of {\tt sstatus}.SUM. \\ \hline
 \end{tabular}
\end{center}
\caption{Effect on load and store translation and protection under MPRV.  When MPRV=1, MPP$\neq$M, and {\tt hstatus}.SPRV=1, the effective privilege is furhter modified: {\tt sstatus}.SPP applies instead of MPP, and {\tt hstatus}.SPV applies instead of MPV.}
\label{h-mprv}
\end{table*}
