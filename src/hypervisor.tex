\chapter{Hypervisor Extension, Version 0.0}
\label{hypervisor}

This chapter describes the RISC-V hypervisor extension, which virtualizes the
supervisor-level architecture to efficiently host guest operating systems atop
a type-1 or type-2 hypervisor.  The hypervisor extension adds a second level
of address translation, from supervisor physical addresses to
hypervisor physical addresses, to virtualize the memory and memory-mapped I/O
subsystems.  The hypervisor extension also adds a new privilege mode, {\em
hypervisor mode} (H-mode), where the hypervisor runs.  H-mode acts the same as
S-mode, but with additional instructions and CSRs that control second-level
address translation and support hosting an S-mode guest.  Existing S-mode
operating systems can execute without modification either in H-mode or as
S-mode guests.

An H-mode OS or hypervisor interacts with the machine through the same SBI
as would an S-mode OS.  An H-mode hypervisor is expected to implement the
SBI for its S-mode guest.

\begin{commentary}
The baseline privileged architecture is designed to simplify the use of classic
virtualization techniques, where a guest OS is run at user-level, as
the few privileged instructions can be easily detected and trapped.
The hypervisor extension improves virtualization performance by
reducing the frequency of these traps.

The hypervisor extension has been designed to be efficiently
emulable on platforms that do not implement the extension, by running
the hypervisor in S-mode and trapping into M-mode for H-mode CSR accesses
and to maintain shadow page tables.  The majority of CSR accesses for
type-2 hypervisors are valid S-mode accesses so need not be trapped.
Hypervisors can support nested virtualization analogously.
\end{commentary}

The hypervisor extensions are enabled by setting bit 7 in the {\tt misa} CSR,
which corresponds to the letter H.  When {\tt misa}[7] is clear, the hart
behaves as though this extension were not implemented, and attempts to use
hypervisor CSRs or instructions raise an illegal instruction exception.

\section{Privilege Modes}

The current {\em virtualization mode}, denoted V, indicates whether the hart
is currently executing in a guest.  When V=1, the hart is either in S-mode, or
in U-mode under an S-mode OS.  When V=0, the hart is either in M-mode, in
H-mode, or in U-mode under an H-mode OS.  The virtualization mode also
indicates whether two-level address translation is active (V=1) or inactive
(V=0).  Table~\ref{h-operating-modes} lists the possible operating modes of
a RISC-V hart with the hypervisor extension.

\begin{table*}[h!]
\begin{center}
\begin{tabular}{|c|c||l|l|l|}
  \hline
   Privilege & Virtualization & \multirow{2}{*}{Abbreviation} & \multirow{2}{*}{Name} & Two-Level \\
   Encoding  & Mode (V)       &                               &                       & Translation \\ \hline
   0         & 0              & U-mode  & User mode & Off \\
   1         & 0              & H-mode  & Hypervisor mode & Off \\
   3         & 0              & M-mode  & Machine mode & Off \\
   0         & 1              & U-mode  & User mode & On \\
   1         & 1              & S-mode  & Supervisor mode & On \\
  \hline
 \end{tabular}
\end{center}
\caption{Operating modes with the hypervisor extension.}
\label{h-operating-modes}
\end{table*}

\section{Hypervisor CSRs}

An H-mode hypervisor uses the S-mode CSRs to interact with the exception,
interrupt, and address-translation subsystems.
Additional CSRs are provided to H-mode, but not to S-mode, to control
the behavior of an S-mode guest:
{\tt hvtval}, {\tt hstatus}, {\tt hedeleg}, and
{\tt hideleg}.

Additionally, several {\em background} supervisor CSRs are copies of one of
the existing {\em foreground} supervisor CSRs.  For example, the {\tt
bsstatus} CSR is the background copy of the foreground {\tt sstatus} CSR.
When transitioning between virtualization modes (V=0 to V=1, or vice-versa),
the implementation swaps the background supervisor CSRs with their foreground
counterparts.  When V=0, the background supervisor CSRs contain the S-mode
guest's version of those CSRs, and the foreground supervisor CSRs contain
H-mode's version.  When V=1, the background supervisor CSRs contain H-mode's
version, and the foreground supervisor CSRs contain the S-mode guest's
version.  The background registers are accessible to H-mode, but not to S-mode.

\subsection{Hypervisor Virtual Trap Value ({\tt hvtval}) Register}

The {\tt hvtval} register is an XLEN-bit read-write register formatted as shown
in Figure~\ref{hvtvalreg}.  When an access fault, page fault, or misaligned
address exception is taken into H-mode, {\tt hvtval} is
written with the original virtual address that caused the exception.
For other traps into H-mode, {\tt hvtval} is written with zero.

\begin{figure}[h!]
{\footnotesize
\begin{center}
\begin{tabular}{@{}J}
\instbitrange{XLEN-1}{0} \\
\hline
\multicolumn{1}{|c|}{\tt hvtval} \\
\hline
XLEN \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Hypervisor virtual trap value register ({\tt hvtval}).}
\label{hvtvalreg}
\end{figure}

\subsection{Hypervisor Status ({\tt hstatus}) Register}

The {\tt hstatus} register is an XLEN-bit read/write register
formatted as shown in Figure~\ref{hstatusreg}.  The {\tt hstatus}
register provides facilities analogous to the {\tt mstatus} register
that track and control the exception behavior of an S-mode guest.

\begin{figure*}[h!]
{\footnotesize
\begin{center}
\setlength{\tabcolsep}{4pt}
\begin{tabular}{EcccWcYccR}
\\
\instbitrange{XLEN-1}{23} &
\instbit{22} &
\instbit{21} &
\instbit{20} &
\instbitrange{19}{18} &
\instbit{17} &
\instbitrange{16}{11} &
\instbit{10} &
\instbit{9} &
\instbitrange{8}{0} \\
\hline
\multicolumn{1}{|c|}{\wpri} &
\multicolumn{1}{c|}{VTSR} &
\multicolumn{1}{c|}{VTW} &
\multicolumn{1}{c|}{VTVM} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{SPRV} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{SPV} &
\multicolumn{1}{c|}{STL} &
\multicolumn{1}{c|}{\wpri} \\
\hline
XLEN-23 & 1 & 1 & 1 & 2 & 1 & 6 & 1 & 1 & 9 \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Hypervisor-mode status register ({\tt hstatus}).}
\label{hstatusreg}
\end{figure*}

The {\tt hstatus} fields VTSR, VTW, and VTVM are defined analogously to the
{\tt mstatus} fields TSR, TW, and TVM, but affect the trapping behavior of the
SRET, WFI, and virtual-memory management instructions in the S-mode guest
only.

The SPV bit (Supervisor Previous Virtualization Mode) is written by the implementation
whenever a trap is taken into H-mode.  Just as the SPP bit in {\tt sstatus} is set to the privilege
mode at the time of the trap, the SPV bit in {\tt hstatus} is set to the value of the virtualization
mode V at the time of the trap.  When an SRET instruction is executed when V=0,
V is set to SPV.

The STL bit (Supervisor Translation Level), which indicates which address-translation level
caused a page-fault exception, is also written by the implementation whenever a trap
is taken into H-mode.  On an access fault, or on a page fault due to H-mode address
translation, STL is set to 0.  For any other trap into H-mode, STL is set to the value
of V at the time of the trap.

The SPRV bit modifies the privilege with which loads and stores execute.
When SPRV=0, translation and protection behave as normal.  When SPRV=1,
load and store memory addresses are translated and protected as though
the current privilege mode were set to {\tt sstatus}.SPP and the current
virtualization mode were set to {\tt hstatus}.SPV.
Table~\ref{h-sprv} enumerates the cases.

\begin{table*}[h!]
\begin{center}
\begin{tabular}{|c|c|c||p{5in}|}
  \hline
   SPRV & SPP & SPV & Effect \\ \hline \hline
   0    & --  & -- & Normal access; current privilege and virtualization modes apply. \\ \hline
   1    & 0   & 0  & U-level access with H-level translation and protection only. \\ \hline
   1    & 1   & 0  & H-level access with H-level translation and protection only. \\ \hline
   1    & 0   & 1  & U-level access with two-level translation and protection. {\tt sstatus}.MXR makes any executable page readable.  {\tt bsstatus}.MXR makes readable those pages marked executable at the S-mode translation level only if readable at the H-mode translation level. \\ \hline
   1    & 1   & 1  & S-level access with two-level translation and protection. {\tt sstatus}.MXR makes any executable page readable.  {\tt bsstatus}.MXR makes readable those pages marked executable at the S-mode translation level only if readable at the H-mode translation level. {\tt bsstatus}.SUM applies instead of {\tt sstatus}.SUM. \\ \hline
 \end{tabular}
\end{center}
\caption{Effect on load and store translation and protection under SPRV.}
\label{h-sprv}
\end{table*}

\begin{commentary}
For simplicity, SPRV is in effect even when in S-mode or U-mode, but in normal
use will only be enabled for short sequences in H-mode.
\end{commentary}

\subsection{Hypervisor Trap Delegation Registers ({\tt hedeleg} and {\tt hideleg})}

By default, all traps at any privilege level are handled in M-mode, though
M-mode usually uses the {\tt medeleg} and {\tt mideleg} CSRs to delegate
some traps to H-mode.  The {\tt hedeleg} and {\tt hideleg} CSRs allow these
traps to be further delegated to an S-mode guest; their layout is the same
as {\tt medeleg} and {\tt mideleg}.

\begin{figure}[h!]
{\footnotesize
\begin{center}
\begin{tabular}{@{}U}
\instbitrange{XLEN-1}{0} \\
\hline
\multicolumn{1}{|c|}{Synchronous Exceptions (\warl)} \\
\hline
XLEN \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Hypervisor Exception Delegation Register {\tt hedeleg}.}
\label{hedelegreg}
\end{figure}

\begin{figure}[h!]
{\footnotesize
\begin{center}
\begin{tabular}{@{}U}
\instbitrange{XLEN-1}{0} \\
\hline
\multicolumn{1}{|c|}{Interrupts (\warl)} \\
\hline
XLEN \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Hypervisor Interrupt Delegation Register {\tt hideleg}.}
\label{hidelegreg}
\end{figure}

The {\tt hedeleg} and {\tt hideleg} registers are only active when V=1.  When
V=1, any trap that has been delegated to H-mode (using {\tt medeleg} or {\tt
mideleg}) is further delegated to S-mode if the corresponding {\tt hedeleg} or
{\tt hideleg} bit is set.  If the N extension for user-mode interrupts
is implemented, the S-mode guest may further delegate the interrupt
to U-mode by setting the corresponding bit in {\tt sedeleg} or {\tt sideleg}.

When V=0 and the N extension for user-mode interrupts is implemented, any trap
that has been delegated to H-mode can be further delegated to U-mode by
setting the corresponding bit in {\tt sedeleg} or {\tt sideleg}.

\subsection{Background Supervisor Status ({\tt bsstatus}) Register}

The {\tt sstatus} register is an XLEN-bit read/write register formatted as
shown in Figure~\ref{bsstatusreg}.  When V=0, the {\tt bsstatus} register
holds the S-mode guest's version of several fields of the {\tt sstatus}
register: UXL, MXR, SUM, FS, SPP, SPIE, and SIE.  When V=1, {\tt bsstatus}
holds H-mode's version of these fields.  When transitioning between
virtualization modes (V=0 to V=1, or vice-versa), the implementation swaps
these fields in {\tt bsstatus} with their counterparts in {\tt sstatus}.  The
other fields in {\tt sstatus} are unchanged.

When V=0, {\tt bsstatus} does not directly affect the behavior of the machine,
unless the MPRV feature in the {\tt mstatus} register or the SPRV feature
in the {\tt hstatus} register is used to execute a load or store
{\em as though} V=1.

\begin{figure*}[h!]
{\footnotesize
\begin{center}
\setlength{\tabcolsep}{4pt}
\begin{tabular}{McEccc}
\\
\instbitrange{XLEN-1}{34} &
\instbitrange{33}{32} &
\instbitrange{31}{20} &
\instbit{19} &
\instbit{18} &
 \\
\hline
\multicolumn{1}{|c|}{\wpri} &
\multicolumn{1}{c|}{UXL} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{MXR} &
\multicolumn{1}{c|}{SUM} &
 \\
\hline
XLEN-34 & 2 & 12 & 1 & 1 & \\
\end{tabular}
\begin{tabular}{cFFYcWcFcc}
\\
&
\instbitrange{17}{15} &
\instbitrange{14}{13} &
\instbitrange{12}{9} &
\instbit{8} &
\instbitrange{7}{6} &
\instbit{5} &
\instbitrange{4}{2} &
\instbit{1} &
\instbit{0} \\
\hline
 &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{FS[1:0]} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{SPP} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{SPIE} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{SIE} &
\multicolumn{1}{c|}{\wpri} \\
\hline
 & 3 & 2 & 4 & 1 & 2 & 1 & 3 & 1 & 1 \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Background supervisor status register ({\tt bsstatus}) for RV64 and RV128.}
\label{bsstatusreg}
\end{figure*}

\subsection{Background Supervisor Interrupt Registers ({\tt bsip} and {\tt bsie})}

The {\tt bsip} register is an XLEN-bit read/write register formatted as shown
in Figure~\ref{bsipreg}.  When V=0, the {\tt bsip} register holds the S-mode
guest's version of the {\tt sip} register.  When V=1, {\tt bsip} holds
H-mode's version of the {\tt sip} register.  When transitioning between
virtualization modes (V=0 to V=1, or vice-versa), the implementation swaps the
contents of {\tt bsip} and {\tt sip}.

\note{AW: Need to describe how {\tt bsip}.SEIP interacts with PLIC.  I think {\tt bsip}.SEIP should purely be a read-write storage bit to emulate the PLIC for S-mode; the PLIC should not be wired into {\tt bsip}.SEIP.}

\begin{figure*}[h!]
{\footnotesize
\begin{center}
\setlength{\tabcolsep}{4pt}
\begin{tabular}{TcFcFcc}
\instbitrange{XLEN-1}{10} &
\instbit{9} &
\instbitrange{8}{6} &
\instbit{5} &
\instbitrange{4}{2} &
\instbit{1} &
\instbit{0} \\
\hline
\multicolumn{1}{|c|}{\wiri} &
\multicolumn{1}{c|}{SEIP} &
\multicolumn{1}{c|}{\wiri} &
\multicolumn{1}{c|}{STIP} &
\multicolumn{1}{c|}{\wiri} &
\multicolumn{1}{c|}{SSIP} &
\multicolumn{1}{c|}{\wiri} \\
\hline
XLEN-10 & 1 & 3 & 1 & 3 & 1 & 1 \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Background supervisor interrupt-pending register ({\tt bsip}).}
\label{bsipreg}
\end{figure*}

The {\tt bsie} register is an XLEN-bit read/write register formatted as shown
in Figure~\ref{bsiereg}.  When V=0, the {\tt bsie} register holds the S-mode
guest's version of the {\tt sie} register.  When V=1, {\tt bsie} holds
H-mode's version of the {\tt sie} register.  When transitioning between
virtualization modes (V=0 to V=1, or vice-versa), the implementation swaps the
contents of {\tt bsie} and {\tt sie}.

\begin{figure*}[h!]
{\footnotesize
\begin{center}
\setlength{\tabcolsep}{4pt}
\begin{tabular}{TcFcFcc}
\instbitrange{XLEN-1}{10} &
\instbit{9} &
\instbitrange{8}{6} &
\instbit{5} &
\instbitrange{4}{2} &
\instbit{1} &
\instbit{0} \\
\hline
\multicolumn{1}{|c|}{\wpri} &
\multicolumn{1}{c|}{SEIE} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{STIE} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{SSIE} &
\multicolumn{1}{c|}{\wiri} \\
\hline
XLEN-10 & 1 & 3 & 1 & 3 & 1 & 1 \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Background supervisor interrupt-enable register ({\tt bsie}).}
\label{bsiereg}
\end{figure*}

When V=0, {\tt bsip} and {\tt bsie} do not affect the behavior of the machine.
When V=1, they hold the active interrupt-pending and interrupt-enable bits,
respectively, for H-mode; if any bit position holds a 1 in both registers, an
interrupt will be taken.

\begin{commentary}
The {\tt bsip} and {\tt bsie} CSRs do not hold copies of the user-mode
interrupt fields.  The expectation is that the context-switch code
will swap the {\tt uip} and {\tt uie} CSRs
along with the other user-mode interrupt
registers ({\tt ustatus}, {\tt utvec}, etc.) if that feature is enabled.
\end{commentary}

\subsection{Background Supervisor Trap Vector Base Address Register ({\tt bstvec})}

The {\tt bstvec} register is an XLEN-bit read/write register formatted as shown
in Figure~\ref{bstvecreg}.  When V=0, the {\tt bstvec} register holds the
S-mode guest's version of the {\tt stvec} register.  When V=1, {\tt bstvec}
holds H-mode's version of the {\tt stvec} register.  When transitioning between
virtualization modes (V=0 to V=1, or vice-versa), the implementation swaps the
contents of {\tt bstvec} and {\tt stvec}.

When V=0, {\tt bstvec} does not directly affect the behavior of the machine.  When V=1,
it controls the value to which the {\tt pc} will be set upon a trap into
H-mode.

\begin{figure*}[h!]
{\footnotesize
\begin{center}
\begin{tabular}{J@{}R}
\instbitrange{XLEN-1}{2} &
\instbitrange{1}{0} \\
\hline
\multicolumn{1}{|c|}{BASE[XLEN-1:2] (\warl)} & 
\multicolumn{1}{c|}{MODE (\warl)} \\
\hline
XLEN-2 & 2 \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Background supervisor trap vector base address register ({\tt bstvec}).}
\label{bstvecreg}
\end{figure*}

\subsection{Background Supervisor Scratch Register ({\tt bsscratch})}

The {\tt bsscratch} register is an XLEN-bit read/write register formatted as shown
in Figure~\ref{bsscratchreg}.  When V=0, the {\tt bsscratch} register holds the
S-mode guest's version of the {\tt sscratch} register.  When V=1, {\tt bsscratch}
holds H-mode's version of the {\tt sscratch} register.  When transitioning between
virtualization modes (V=0 to V=1, or vice-versa), the implementation swaps the
contents of {\tt bsscratch} and {\tt sscratch}.

Typically, {\tt bsscratch} is used to hold a pointer to the hart-local
hypervisor context (when V=1) or supervisor context (when V=0).  The
contents of {\tt bsscratch} do not directly affect the behavior of
the machine.

\begin{figure*}[h!]
{\footnotesize
\begin{center}
\begin{tabular}{@{}J}
\instbitrange{XLEN-1}{0} \\
\hline
\multicolumn{1}{|c|}{\tt bsscratch} \\
\hline
XLEN \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Background supervisor scratch register ({\tt bsscratch}).}
\label{bsscratchreg}
\end{figure*}

\subsection{Background Supervisor Exception Program Counter ({\tt bsepc})}

The {\tt bsepc} register is an XLEN-bit read/write register formatted as shown
in Figure~\ref{bsepcreg}.  When V=0, the {\tt bsepc} register holds the
S-mode guest's version of the {\tt sepc} register.  When V=1, {\tt bsepc}
holds H-mode's version of the {\tt sepc} register.  When transitioning between
virtualization modes (V=0 to V=1, or vice-versa), the implementation swaps the
contents of {\tt bsepc} and {\tt sepc}.

The contents of {\tt bsepc} do not directly affect the behavior of
the machine.

{\tt bsepc} is a \warl\ register that must be able to hold the same set of
values that {\tt sepc} can hold.

\begin{figure*}[h!]
{\footnotesize
\begin{center}
\begin{tabular}{@{}J}
\instbitrange{XLEN-1}{0} \\
\hline
\multicolumn{1}{|c|}{\tt bsepc} \\
\hline
XLEN \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Background supervisor exception program counter ({\tt bsepc}).}
\label{bsepcreg}
\end{figure*}

\subsection{Background Supervisor Cause Register ({\tt bscause})}

The {\tt bscause} register is an XLEN-bit read/write register formatted as shown
in Figure~\ref{bscausereg}.  When V=0, the {\tt bscause} register holds the
S-mode guest's version of the {\tt scause} register.  When V=1, {\tt bscause}
holds H-mode's version of the {\tt scause} register.  When transitioning between
virtualization modes (V=0 to V=1, or vice-versa), the implementation swaps the
contents of {\tt bscause} and {\tt scause}.

The contents of {\tt bscause} do not directly affect the behavior of
the machine.

{\tt bscause} is a \wlrl\ register that must be able to hold the same set of
values that {\tt scause} can hold.

\begin{figure*}[h!]
{\footnotesize
\begin{center}
\begin{tabular}{c@{}U}
\instbit{XLEN-1} &
\instbitrange{XLEN-2}{0} \\
\hline
\multicolumn{1}{|c|}{Interrupt} &
\multicolumn{1}{c|}{Exception Code (\wlrl)} \\
\hline
1 & XLEN-1 \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Background supervisor cause register ({\tt bscause}).}
\label{bscausereg}
\end{figure*}

\subsection{Background Supervisor Trap Value Register ({\tt bstval})}

The {\tt bstval} register is an XLEN-bit read/write register formatted as shown
in Figure~\ref{bstvalreg}.  When V=0, the {\tt bstval} register holds the
S-mode guest's version of the {\tt stval} register.  When V=1, {\tt bstval}
holds H-mode's version of the {\tt stval} register.  When transitioning between
virtualization modes (V=0 to V=1, or vice-versa), the implementation swaps the
contents of {\tt bstval} and {\tt stval}.

The contents of {\tt bstval} do not directly affect the behavior of
the machine.

{\tt bstval} is a \warl\ register that must be able to hold the same set of
values that {\tt stval} can hold.

\begin{figure*}[h!]
{\footnotesize
\begin{center}
\begin{tabular}{@{}J}
\instbitrange{XLEN-1}{0} \\
\hline
\multicolumn{1}{|c|}{\tt bstval} \\
\hline
XLEN \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Background supervisor trap value register ({\tt bstval}).}
\label{bstvalreg}
\end{figure*}

\subsection{Background Address Translation and Protection Register ({\tt bsatp})}

The {\tt bsatp} register is an XLEN-bit read/write register formatted as shown
in Figure~\ref{bsatpreg}.  When V=0, the {\tt bsatp} register holds the
S-mode guest's version of the {\tt satp} register.  When V=1, {\tt bsatp}
holds H-mode's version of the {\tt satp} register.  When transitioning between
virtualization modes (V=0 to V=1, or vice-versa), the implementation swaps the
contents of {\tt bsatp} and {\tt satp}.

When V=0, {\tt bsatp} does not directly affect the behavior of the machine.  When V=1,
it controls the translation of supervisor physical addresses to
hypervisor physical addresses.  The interpretation of the MODE, ASID, and PPN
fields is the same as for {\tt satp}.

\begin{figure*}[h!]
{\footnotesize
\begin{center}
\begin{tabular}{@{}S@{}T@{}U}
\instbitrange{63}{60} &
\instbitrange{59}{44} &
\instbitrange{43}{0} \\
\hline
\multicolumn{1}{|c|}{{\tt MODE} (\warl)} &
\multicolumn{1}{|c|}{{\tt ASID} (\warl)} &
\multicolumn{1}{|c|}{{\tt PPN}  (\warl)} \\
\hline
4 & 16 & 44 \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{RV64 background supervisor address translation and protection register {\tt satp}, for MODE
values Sv39 and Sv48.}
\label{bsatpreg}
\end{figure*}

\section{Hypervisor Instructions}

The hypervisor extension adds one new instruction, HRET, which is valid only in
H-mode or M-mode, and when {\tt mstatus}.TSR=0.  HRET sets {\tt hstatus}.SPV=1,
then performs an SRET.

\begin{commentary}
As compared to setting {\tt hstatus}.SPV then executing SRET, HRET halves the
number of emulation traps when executing an H-mode hypervisor on an
implementation without hypervisor extensions, or when recursively
virtualizing.  The need to set {\tt hstatus}.SPV before executing SRET arises
when the hypervisor takes an interrupt while servicing a trap from a guest,
because the nested interrupt clears {\tt hstatus}.SPV.
\end{commentary}

\section{Machine-Level CSRs}

The hypervisor extension adds one new machine-level CSR, {\tt mvtval}, and
augments the {\tt mstatus} CSR.

\subsection{Machine Virtual Trap Value ({\tt mvtval}) Register}

The {\tt mvtval} register is an XLEN-bit read-write register formatted as shown
in Figure~\ref{mvtvalreg}.  When an access fault, page fault, or misaligned
address exception is taken into M-mode, {\tt mvtval} is
written with the original virtual address that caused the exception.
For other traps into M-mode, {\tt mvtval} is written with zero.

\begin{figure}[h!]
{\footnotesize
\begin{center}
\begin{tabular}{@{}J}
\instbitrange{XLEN-1}{0} \\
\hline
\multicolumn{1}{|c|}{\tt mvtval} \\
\hline
XLEN \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Machine Virtual Trap Value register ({\tt mvtval}).}
\label{mvtvalreg}
\end{figure}

\subsection{Machine Status Register ({\tt mstatus})}

The hypervisor extension adds two fields to the machine-mode {\tt mstatus} CSR,
MPV and MTL,
and modifies the behavior of several existing fields.
Figure~\ref{hypervisor-mstatus} shows the {\tt mstatus} register when the
hypervisor extension is provided.

\begin{figure*}[h!]
{\footnotesize
\begin{center}
\setlength{\tabcolsep}{4pt}
\begin{tabular}{cYccYccccccc}
\\
\instbit{XLEN-1} &
\instbitrange{XLEN-2}{36} &
\instbitrange{35}{34} &
\instbitrange{33}{32} &
\instbitrange{31}{23} &
\instbit{22} &
\instbit{21} &
\instbit{20} &
\instbit{19} &
\instbit{18} &
\instbit{17} &
 \\
\hline
\multicolumn{1}{|c|}{SD} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{SXL[1:0]} &
\multicolumn{1}{c|}{UXL[1:0]} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{TSR} &
\multicolumn{1}{c|}{TW} &
\multicolumn{1}{c|}{TVM} &
\multicolumn{1}{c|}{MXR} &
\multicolumn{1}{c|}{SUM} &
\multicolumn{1}{c|}{MPRV} &
 \\
\hline
1 & XLEN-37 & 2 & 2 & 9 & 1 & 1 & 1 & 1 & 1 & 1 & \\
\end{tabular}
\begin{tabular}{ccccccccccccccc}
\\
&
\instbitrange{16}{15} &
\instbitrange{14}{13} &
\instbitrange{12}{11} &
\instbit{10} &
\instbit{9} &
\instbit{8} &
\instbit{7} &
\instbit{6} &
\instbit{5} &
\instbit{4} &
\instbit{3} &
\instbit{2} &
\instbit{1} &
\instbit{0} \\
\hline
 &
\multicolumn{1}{|c|}{XS[1:0]} &
\multicolumn{1}{c|}{FS[1:0]} &
\multicolumn{1}{c|}{MPP[1:0]} &
\multicolumn{1}{c|}{MPV} &
\multicolumn{1}{c|}{MTL} &
\multicolumn{1}{c|}{SPP} &
\multicolumn{1}{c|}{MPIE} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{SPIE} &
\multicolumn{1}{c|}{UPIE} &
\multicolumn{1}{c|}{MIE} &
\multicolumn{1}{c|}{\wpri} &
\multicolumn{1}{c|}{SIE} &
\multicolumn{1}{c|}{UIE} \\
\hline
 & 2 & 2 & 2 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 \\
\end{tabular}
\end{center}
}
\vspace{-0.1in}
\caption{Machine-mode status register ({\tt mstatus}) for RV64 and RV128.}
\label{hypervisor-mstatus}
\end{figure*}

The MPV bit (Machine Previous Virtualization Mode) is written by the implementation
whenever a trap is taken into M-mode.  Just as the MPP bit is set to the privilege
mode at the time of the trap, the MPV bit is set to the value of the virtualization
mode V at the time of the trap.  When an MRET instruction is executed, the
virtualization mode V is set to MPV.

The MTL bit (Machine Translation Level), which indicates which address-translation level
caused a page-fault exception, is also written by the implementation whenever a trap
is taken into M-mode.  On an access fault, or on a page fault due to H-mode address
translation, MTL is set to 0.  For any other trap into M-mode, MTL is set to the value
of V at the time of the trap.

The SXL field controls the value of XLEN for H-mode.
The UXL field controls the value of XLEN for S-mode when V=1, or for U-mode when V=0.

The TSR and TVM fields only affect execution in H-mode.

The TW field affect execution in both H-mode and S-mode.

The hypervisor extension changes the behavior of the the Modify Privilege
field, MPRV.  When MPRV=0, translation and protection behave as normal.  When
MPRV=1, loads and stores are translated and protected as though the current
privilege mode were set to MPP and the current virtualization mode were set to
MPV.  Table~\ref{h-mprv} enumerates the cases.

\begin{table*}[h!]
\begin{center}
\begin{tabular}{|c|c|c||p{5in}|}
  \hline
   MPRV & MPP & MPV & Effect \\ \hline \hline
   0    & --  & -- & Normal access; current privilege and virtualization modes apply. \\ \hline
   1    & 3   & -- & M-level access with no translation. \\ \hline
   1    & 0   & 0  & U-level access with H-level translation and protection only. \\ \hline
   1    & 1   & 0  & H-level access with H-level translation and protection only.  \\ \hline
   1    & 0   & 1  & U-level access with two-level translation and protection. {\tt sstatus}.MXR makes any executable page readable.  {\tt bsstatus}.MXR makes readable those pages marked executable at the S-mode translation level only if readable at the H-mode translation level. \\ \hline
   1    & 1   & 1  & S-level access with two-level translation and protection. {\tt sstatus}.MXR makes any executable page readable.  {\tt bsstatus}.MXR makes readable those pages marked executable at the S-mode translation level only if readable at the H-mode translation level. {\tt bsstatus}.SUM applies instead of {\tt sstatus}.SUM. \\ \hline
 \end{tabular}
\end{center}
\caption{Effect on load and store translation and protection under MPRV.  When MPRV=1, MPP$\neq$M, and {\tt hstatus}.SPRV=1, the effective privilege is furhter modified: {\tt sstatus}.SPP applies instead of MPP, and {\tt hstatus}.SPV applies instead of MPV.}
\label{h-mprv}
\end{table*}

The {\tt mstatus} register is a superset of the {\tt sstatus} register;
modifying a field in {\tt sstatus} modifies the homonymous field in {\tt
mstatus}, and vice-versa.

\section{Two-Level Address Translation}

Whenever the current virtualization mode V is 1, two-level address translation
and protection is in effect.  For any virtual memory access, the original {\em
user virutal address} or {\em supervisor virtual address} is first converted
by S-level address translation, as controlled by the {\tt satp} register, into
a {\em supervisor physical address}.  The supervisor physical address is then
converted by H-level address translation, as controlled by the {\tt bsatp}
register, into a {\em hypervisor physical address}.
Although there is no option to disable two-level address translation when V=1,
either level of translation can be effectively disabled by zeroing the
corresponding {\tt satp} or {\tt bsatp} register.

For the purposes of H-level address translation and protection, all memory
accesses made with V=1---including those made by the S-level
address-translation hardware---are considered user-level accesses.  In
addition to satisfying S-level translation and protection, the access type
must be permitted at user level by H-level translation and protection.
The user page protections at H level are perceived by S-mode as physical
memory protection.

H-level memory protection faults caused by accesses with V=1 raise the
page-fault exception corresponding to the original access type.  H-level
memory protection faults are treated as H-level exceptions for the purpose of
exception delegation, and so are not delegated to S-mode, regardless of the
setting of the {\tt hedeleg} register.

Note that the S-level MXR setting, which makes execute-only pages readable,
only overrides S-level page protection.  Setting MXR at S-level does not override
H-level page protections.  Setting MXR at H-level, however, overrides
both H-level and S-level execute-only permissions.

For the purposes of H-level address translation protection, memory accesses
made with V=0 are considered supervisor-level accesses.  For example, for an
H-mode virtual memory access to succeed, the corresponding H-level page-table
entry must not have its U bit set, unless overridden by {\tt sstatus}.SUM.

\section{Base ISA Control}

The {\tt mstatus} field SXL determines XLEN for H-mode.

When executing in S-mode, XLEN is determined by the the UXL field of the
background register {\tt bsstatus}.  Because {\tt bsstatus} is swapped with
{\tt sstatus} when transitioning from S-mode into H-mode or M-mode, H-mode and
M-mode control S-mode's XLEN via the UXL field of the foreground register {\tt
sstatus}.

When executing in U-mode, XLEN is determined by the UXL field of the foreground register {\tt sstatus}.

\begin{commentary}
H-mode controls unvirtualized U-mode's XLEN the same way it controls virtualized S-mode's XLEN, via
{\tt sstatus}.UXL.
\end{commentary}

\section{Traps}

The hypervisor extension modifies the environment-call exception cause
encoding.  Environment calls from H-mode use cause 9, whereas environment
calls from an S-mode guest now use cause 10.  Table~\ref{hcauses} lists the
possible M-mode and H-mode exception codes when the hypervisor extension is
present.

\begin{commentary}
H-mode and S-mode ECALLs use different cause values so they can be delegated
separately.  Without the hypervisor extension, cause 9 is used for S-mode
environment calls.  Using cause 9 for H-mode environment calls when the
hypervisor extension is enabled simplifies M-mode software.
\end{commentary}

\begin{table*}[h!]
\begin{center}
\begin{tabular}{|r|r|l|l|}

  \hline
  Interrupt & Exception Code  & Description \\
  \hline	 
  1         & 0               & User software interrupt \\
  1         & 1               & Supervisor software interrupt \\
  1         & 2--3            & {\em Reserved} \\
  1         & 4               & User timer interrupt \\
  1         & 5               & Supervisor timer interrupt \\
  1         & 6--7            & {\em Reserved} \\
  1         & 8               & User external interrupt \\
  1         & 9               & Supervisor external interrupt \\
  1         & $\ge$10         & {\em Reserved} \\ \hline
  0         & 0               & Instruction address misaligned \\
  0         & 1               & Instruction access fault \\
  0         & 2               & Illegal instruction \\   
  0         & 3               & Breakpoint \\
  0         & 4               & Load address misaligned \\
  0         & 5               & Load access fault \\
  0         & 6               & Store/AMO address misaligned \\
  0         & 7               & Store/AMO access fault \\
  0         & 8               & Environment call from U-mode \\
  0         & 9               & Environment call from H-mode \\
  0         & 10              & Environment call from S-mode \\
  0         & 11              & {\em Reserved} \\
  0         & 12              & Instruction page fault \\
  0         & 13              & Load page fault \\
  0         & 14              & {\em Reserved} \\
  0         & 15              & Store/AMO page fault \\
  0         & $\ge$16         & {\em Reserved} \\
  \hline
\end{tabular}
\end{center}
\caption{Supervisor and machine cause register ({\tt scause} and {\tt mcause}) values when hypervisor extension is enabled.}
\label{hcauses}
\end{table*}

When a trap occurs in H-mode, or in U-mode with V=0, it goes to M-mode, unless
delegated by {\tt medeleg} or {\tt mideleg}, in which case it goes to H-mode.
If the N extension for user-mode interrupts is implemented, then U-mode (V=0)
traps destined for H-mode may be further delegated to U-mode using the {\tt
sedeleg} and {\tt sideleg} CSRs.

When a trap occurs in S-mode, or in U-mode with V=1, it goes to M-mode, unless
delegated by {\tt medeleg} or {\tt mideleg}, in which case it goes to H-mode,
unless further delegated by {\tt hedeleg} or {\tt hideleg}, in which case it
goes to S-mode.  If the N extension for user-mode interrupts is implemented,
then U-mode traps destined for S-mode may be further delegated to U-mode
using the {\tt sedeleg} and {\tt sideleg} CSRs.

When a trap is taken into M-mode, then if the virtualization mode V was 1, the
contents of the background supervisor registers are first
swapped with their foreground counterparts.  Then, {\tt mstatus}.MPP and {\tt
mstatus}.MPV are set according to Table~\ref{h-mpp}.

\begin{table*}[h!]
\begin{center}
\begin{tabular}{|l|c|c|}
  \hline
  Previous Mode & MPP & MPV \\ \hline
  U-mode, V=1   & 0   & 1 \\
  U-mode, V=0   & 0   & 0 \\
  S-mode        & 1   & 1 \\
  H-mode        & 1   & 0 \\
  M-mode        & 3   & 0 \\ \hline
\end{tabular}
\end{center}
\caption{Value of {\tt mstatus} fields MPP and MPV after a trap into M-mode.
Upon trap return, MPV is ignored when MPP=3.}
\label{h-mpp}
\end{table*}

When a trap is taken into H-mode, then if the virtualization mode V was 1, the
contents of the background supervisor registers are first
swapped with their foreground counterparts.  Then, {\tt sstatus}.SPP and {\tt
sstatus}.SPV are set according to Table~\ref{h-spp}.

\begin{table*}[h!]
\begin{center}
\begin{tabular}{|l|c|c|}
  \hline
  Previous Mode & SPP & SPV \\ \hline
  U-mode, V=1   & 0   & 1 \\
  U-mode, V=0   & 0   & 0 \\
  S-mode        & 1   & 1 \\
  H-mode        & 1   & 0 \\ \hline
\end{tabular}
\end{center}
\caption{Value of {\tt sstatus} fields SPP and SPV after a trap into H-mode.}
\label{h-spp}
\end{table*}

When a trap is taken into S-mode, {\tt sstatus}.SPP is set according to
Table~\ref{h-vspp}.  The {\tt sstatus}.SPV
bit is not modified, and the current virtualization state V remains 1.

\begin{table*}[h!]
\begin{center}
\begin{tabular}{|l|c|c|}
  \hline
  Previous Mode & SPP \\ \hline
  U-mode, V=1   & 0   \\
  S-mode        & 1   \\ \hline
\end{tabular}
\end{center}
\caption{Value of {\tt sstatus} field SPP after a trap into S-mode.}
\label{h-vspp}
\end{table*}

\section{Trap Return}

The MRET instruction is used to return from a trap into M-mode.  MRET sets the
privilege mode according to the values in {\tt mstatus}.MPP and {\tt
mstatus}.MPV, as encoded in Table~\ref{h-mpp}.  MRET then sets {\tt pc}={\tt
mepc}, then in {\tt mstatus} sets MPP=0, MPIE=MIE, then MPIE=1.  Finally, if
MRET changed the current virtualization state V, the contents of the
background supervisor registers are swapped with their foreground
counterparts.

The SRET instruction is usually used to return from a trap into H-mode or
S-mode.  Its behavior depends on the current virtualization mode.  When
executed in M-mode or H-mode (i.e., V=0), SRET sets the privilege mode
according to the values in {\tt sstatus}.SPP and {\tt sstatus}.SPV, as encoded
in Table~\ref{h-spp}.  When executed in S-mode (i.e., V=1), SRET sets the
privilege mode according to Table~\ref{h-vspp}.  In either case, SRET then
sets {\tt pc}={\tt sepc}, then in {\tt sstatus} sets SPP=0, SPIE=SIE, then
SPIE=1.  Finally, if SRET changed the current virtualization state V, the
contents of the background supervisor registers are swapped with their
foreground counterparts.

The HRET instruction can be used to return from H-mode into a virtualized
guest.  It first sets {\tt sstatus.SPV}=1, then performs the same actions as
SRET.
